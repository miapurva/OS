#include <iostream>
#include "roundrobin.h"
#include <cstdlib>
#include <ctime>
using namespace std;

int rear=-1;
int front=-1;

void roundround::dequeue(int RQ[])
{
	if(front==rear)
	{
		cout<<"Queue is empty\n";
	}
	else
	{
		//pid[front]=remove;
		front=front+1;
	}
}
void roundround::enqueue(int RQ[],int add)
{
	cout<<"Added "<<add<<endl;
	if (rear>=n-1)
	{
		cout<<"Queue is full\n";
	}
	else
	{
	rear=rear+1; 
	RQ[rear]=add;
	}
}
void roundround::display(int RQ[])
{
	if(rear==front)
	{
		cout <<"Queue is empty\n";
	}
	for(int i=front+1;i<=rear;i++)
		cout <<RQ[i]<<" ";
}

void roundround::roundr()
{
	srand(time(NULL));
	int TQ,temp,b;
	int RQ[n];
	float sum_wait=0;

	cout<<"\t\t\t\tRound_Robin\n";
	cout<<"\t\t\t\t-----------\n";
	cout<<"Choose your type of input:\n";
	cout<<"\tManual inputs: (0)\t";
	cout<<"\tAutogenerated inputs (1)\n";
	cout<<"Answer: ";
	cin>>b;
	if(b==0)
	{
		cout<<"Enter the number of processes:\n";
		cin>>n;
		cout<<"Enter the Time Quantum value:\n";
		cin>>TQ;
		for(int i=0; i<n; i++)
		{
			cout<<"Enter the arrival time:\t";
			cin>>arrival_Time[i];
			cout<<"Enter the Burst time:\t";
			cin>>burst_Time[i];
			remaining_Time[i]=burst_Time[i];
			pid[i]=i+1;
		}
	}
	else if(b==1)
	{
		n=rand()%7;
		TQ=(rand()%5)+1;
		for(int i=0; i<n; i++)
			{	
				pid[i]=i+1;
				arrival_Time[i]=rand()%10;
				burst_Time[i]=(rand()%10)+1;
				remaining_Time[i]=burst_Time[i];
			}		
	}

	for(int i = 0; i < n-1; i++)
	{
		for (int j = 0; j < n-1-i; j++)
		{
			if(arrival_Time[j]>arrival_Time[j+1])
			{
				temp=arrival_Time[j];
				arrival_Time[j]=arrival_Time[j+1];
				arrival_Time[j+1]=temp;

				temp=burst_Time[j];
				burst_Time[j]=burst_Time[j+1];
				burst_Time[j+1]=temp;

				temp=remaining_Time[j];
				remaining_Time[j]=remaining_Time[j+1];
				remaining_Time[j+1]=temp;

				temp=pid[j];
				pid[j]=pid[j+1];
				pid[j+1]=temp;
			}
		}
	}

	for (int i = 0; i < n; i++)
	{
		check[i]=0;
	}

	//Sorted arrays
	for (int i = 0; i < n; ++i)
	{
		cout<<pid[i]<<" \t"<<arrival_Time[i]<<" \t"<<burst_Time[i]<<"\n";
	}

	cout<<"Arrival Time   Burst Time   Completion Time   TurnAround Time  Waiting Time\n";
	
	int end_time=arrival_Time[0], index,index1, remain=0;
	while(remain!=n)
	{
		int flag=0;
		for (int i = 0; i < n; ++i)
		{
			if(end_time>=arrival_Time[n-1])
			{
				index1=n;
			}
			//process that has come before previous process's completion time
			else if(arrival_Time[i]>end_time)
			{
				index1=i;
				break;
			}
		}
		for (int i = 0; i < index1; ++i)
		{
			int tt=0;
			if(remaining_Time[i]<=burst_Time[i] && remaining_Time[i]>TQ && check[i]==0)
			{
				//enqueuing those processes
				flag=1;
				enqueue(RQ,i);
				index=i;
				remaining_Time[index]-=TQ;
				end_time=end_time+TQ;
				dequeue(RQ);

			}
			else if(remaining_Time[i]<=TQ && check[i]==0)
			{
				index=i;
				remain++;
				check[i]==1;
				remaining_Time[index]=0;
				completion_Time[index]= TQ+end_time;
				tt=completion_Time[index]- arrival_Time[index];
				waiting_Time[index]=tt- burst_Time[index];
				end_time=completion_Time[index];
				dequeue(RQ);
				cout<<"\n\t"<<arrival_Time[index]<<"\t|\t"<<burst_Time[index]<<"\t|\t"<<completion_Time[index]<<"\t|\t"<<tt<<"\t|\t"<<waiting_Time[index]<<endl;

			}
			else if(flag==0)
			{
				end_time++;
			}
		}
	}
	
}