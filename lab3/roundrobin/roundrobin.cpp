#include <iostream>
#include "roundrobin.h"
#include <cstdlib>
#include <ctime>
using namespace std;

void roundround::dequeue(int ready_Queue[], int n)
{
	if(front==rear)
	{
		cout<<"Queue is empty\n";
	}
	else
	{
		//pid[front]=remove;
		front=front+1;
	}
}
void roundround::enqueue(int ready_Queue[], int n,int add)
{
	cout<<"Added "<<add<<endl;
	if (rear>=n-1)
	{
		cout<<"Queue is full\n";
	}
	else
	{
	rear=rear+1; 
	ready_Queue[rear]=add;
	}
}
void roundround::display(int ready_Queue[], int n)
{
	if(rear==front)
	{
		cout <<"Queue is empty\n";
	}
	for(int i=front+1;i<=rear;i++)
		cout <<ready_Queue[i]<<" ";
}

void roundround::roundr()
{
	//srand(time(NULL));
	int n,TQ,temp,b;
	float sum_wait=0;

	cout<<"\t\t\t\tRound_Robin\n";
	cout<<"\t\t\t\t-----------\n";
	cout<<"Choose your type of input:\n";
	cout<<"\tManual inputs: (0)\t";
	cout<<"\tAutogenerated inputs (1)\n";
	cout<<"Answer: ";
	cin>>b;
	if(b==0)
	{
		cout<<"Enter the number of processes:\n";
		cin>>n;
		cout<<"Enter the Time Quantum value:\n";
		cin>>TQ;
		for(int i=0; i<n; i++)
		{
			cout<<"Enter the arrival time:\t";
			cin>>arrival_Time[i];
			cout<<"Enter the Burst time:\t";
			cin>>burst_Time[i];
			remaining_Time[i]=burst_Time[i];
			pid[i]=i+1;
		}
	}
	else if(b==1)
	{
		n=rand()%7;
		TQ=(rand()%5)+1;
		for(int i=0; i<n; i++)
			{	
				pid[i]=i+1;
				arrival_Time[i]=rand()%10;
				burst_Time[i]=(rand()%10)+1;
				remaining_Time[i]=burst_Time[i];
			}		
	}

	for(int i = 0; i < n-1; i++)
	{
		for (int j = 0; j < n-1-i; j++)
		{
			if(arrival_Time[j]>arrival_Time[j+1])
			{
				temp=arrival_Time[j];
				arrival_Time[j]=arrival_Time[j+1];
				arrival_Time[j+1]=temp;

				temp=burst_Time[j];
				burst_Time[j]=burst_Time[j+1];
				burst_Time[j+1]=temp;

				temp=remaining_Time[j];
				remaining_Time[j]=remaining_Time[j+1];
				remaining_Time[j+1]=temp;

				temp=pid[j];
				pid[j]=pid[j+1];
				pid[j+1]=temp;
			}
		}
	}

	for (int i = 0; i < n; i++)
	{
		check[i]=0;
	}

	//Sorted arrays
	/*for (int i = 0; i < n; ++i)
	{
		cout<<pid[i]<<" \t"<<arrival_Time[i]<<" \t"<<burst_Time[i]<<"\n";
	}*/

	cout<<"Arrival Time   Burst Time   Completion Time   TurnAround Time  Waiting Time\n";

	int end_time=0, index,index1, remain=0, time=arrival_Time[0];
	while(remain!=n)
	{
		for (int i = 0; i < n; i++)
		{
			if(arrival_Time[i]<=time && remaining_Time[i]>0)
			{
				index=i;
				enqueue(RQ,	n, index);
				//cout<<"Index "<<index<<endl;
			}
		}
		//new process that won't complete at once
		if(remaining_Time[index]>TQ && index1==RQ[i] && remaining_Time[index]==burst_Time[index])
		{
			//cout<<"Index1"<<index<<endl;
			remaining_Time[index]-=TQ;
			check[index]=2;
			end_time= 0+ TQ;
			dequeue(RQ, n);
			for(int i=0; i<n ;i++)
			{
				if(check[i]==0  && arrival_Time[i]<end_time)
					{
						enqueue(RQ,n,i);
						//cout<<"eenqueue "<<i<<endl;
					}
			}
			for(int i=0; i<n ;i++)
			{
				if(check[i]==2)
					{
						enqueue(RQ,n,i);
						//cout<<"eenqueue "<<i<<endl;
					}
			}
			//enqueue(pid, index);
			
		}
		//half completed process that won't complete even this time
		else if(remaining_Time[index]<burst_Time[index] && remaining_Time[index]>TQ)
		{
			//cout<<"Index2"<<index<<endl;
			remaining_Time[index]-=TQ;
			check[index]=2;
			end_time=end_time+TQ;
			dequeue();
			for(int i=0; i<n ;i++)
			{
				if(check[i]==0 && arrival_Time[i]<end_time)
					{enqueue(RQ,n,i);
					//cout<<"eenqueue "<<i<<endl;
					}
			}
			for(int i=0; i<n ;i++)
			{
				if(check[i]==2)
					{
						enqueue(RQ,n,i);
						//cout<<"eenqueue "<<i<<endl;
					}
			}
		}
			//enqueue(pid, index);
		//completed process
		else if(remaining_Time[index]<=TQ && remaining_Time[index]>0)
		{
			remain++;

			//cout<<"Index3"<<index<<endl;
			check[index]=1;
			for (int i = 0; i < TQ; ++i)
			{
				if(remaining_Time[index]!=0)
					remaining_Time[index]--;
				else if(remaining_Time[index]==0)
				{
					//breakvalue=i;
					break;
				}
			}
			cout<<"End time:\t"<<end_time<<endl;
			completion_Time[index]=end_time + TQ;
			tt=completion_Time[index]- arrival_Time[index];
			waiting_Time[index]=tt- burst_Time[index];
			for(int i=0; i<n ;i++)
			{
				if(check[i]==1 && arrival_Time[i]<completion_Time[i])
					{dequeue(RQ,n);
					cout<<"deequeue "<<i<<endl;
				}
			}
			for(int i=0; i<n ;i++)
			{
				if(check[i]==0 && arrival_Time[i]<completion_Time[i])
					{enqueue(RQ,n,i);
					//cout<<"eenqueue "<<i<<endl;
					}
			}
			/*for(int i=0; i<n ;i++)
			{
				if(check[i]==2)
					{
						enqueue(i);
						cout<<"eenqueue "<<i<<endl;
					}
			}*/
			
			cout<<"\n\t"<<arrival_Time[index]<<"\t|\t"<<burst_Time[index]<<"\t|\t"<<completion_Time[index]<<"\t|\t"<<tt<<"\t|\t"<<waiting_Time[index]<<endl;
		}
		time++;
		//CT=Completion_Time[index]
	}
	
}